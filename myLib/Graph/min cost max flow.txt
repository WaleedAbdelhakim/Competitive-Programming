#include <bits/stdc++.h>

using namespace std;

#define inf 0x3f3f3f3f3f3f3f3f // change if dist is int array

struct edge {
    int from, to, cap, unit_cost;
};

const int N = 215; // make sure is greater than max_node will ever be
long long dist[N];
int par[N] , max_node , src, snk; // don't forget to set src and snk
bool inq[N];

vector<edge> edges;
vector<int> adj[N];

bool spfa() {
    memset(dist, '?' , (max_node + 1) * sizeof dist[0]);
    memset(inq, 0, (max_node + 1) * sizeof inq[0]);
    queue<int> q;
    q.push(src);
    dist[src] = 0;
    inq[src] = 1;
    par[src] = -1;
    while (q.size()) {
        int u = q.front();
        inq[u] = 0;
        q.pop();
        for (int c : adj[u]) {
            auto &e = edges[c];
            if (!e.cap) continue;
            if (dist[e.to] > dist[u] + e.unit_cost) {
                dist[e.to] = dist[u] + e.unit_cost;
                par[e.to] = c;
                if (!inq[e.to]) {
                    inq[e.to] = 1;
                    q.push(e.to);
                }
            }
        }
    }

    return max_node >= snk && dist[snk] != inf;
}

int augment(int eid, int mn) {
    if (eid == -1) return mn;
    auto &e = edges[eid];
    auto &re = edges[eid ^ 1];
    int flow = augment(par[e.from], min(mn, e.cap));
    e.cap -= flow;
    re.cap += flow;
    return flow;
}

void addAugEdge(int u, int v, int cap, int cost) {
    max_node = max(max_node , max(u , v));
    adj[u].push_back(edges.size());
    edges.push_back({u, v, cap, cost});
    adj[v].push_back(edges.size());
    edges.push_back({v, u, 0, -cost}); // c if undirected 0 if directed
}

pair<long long , long long> mcmf() {
    long long flow = 0, cost = 0;
    while (spfa()) {
        int f = augment(par[snk], 1e9); // make sure 1e9 is greater than max cap
        flow += f;
        cost += f * 1ll * dist[snk];
    }
    return {flow, cost};
}

void init() {
    edges.clear();
    for (int i = 0; i <= max_node ; i++)
        adj[i].clear();
    max_node = 0;
}
