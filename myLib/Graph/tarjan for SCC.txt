#include <bits/stdc++.h>

using namespace std;

const int N = 1e5 + 5; // number of nodes
int vis[N] , low[N] , dfsTime[N] , comp_id[N] , Time;
vector<int> adj[N];
stack<int> st;
vector<vector<int> > comps;

int dfs(int node) { // add par if undirected
    if(vis[node])
        return vis[node] == 1 ? low[node] : 1e9;

    dfsTime[node] = low[node] = Time++;
    vis[node] = 1;
    st.push(node);

    for (int child : adj[node]) // in case of undirected continue if par 
        low[node] = min(low[node] , dfs(child));

    if(low[node] == dfsTime[node]) {
        comps.push_back(vector<int>());
        do {
            vis[st.top()] = 2;
            comp_id[st.top()] = comps.size() - 1;
            comps.back().push_back(st.top());
            st.pop();
        } while(comps.back().back() != node);
    }

    return low[node];
}

vector<int> tree[N]; // tree or dag

void tarjan(int n) {
    for (int i = 1 ;i <= n ;i++) // one based 
        if(!vis[i])
            dfs(i);

    for (int i = 1 ;i <= n ;i++) // one based
        for (int child : adj[i])
            if (comp_id[i] != comp_id[child])
                tree[comp_id[i]].push_back(comp_id[child]);
}

void init(int n) { 
    fill(adj , adj + (n + 1) , vector<int>()); // n + 1 for one based
    fill(tree , tree + (n + 1) , vector<int>());
    memset(vis , 0 , (n + 1) * sizeof vis[0]);
    comps.clear();
}
