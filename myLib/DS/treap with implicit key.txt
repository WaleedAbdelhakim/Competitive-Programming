#include <bits/stdc++.h>

//#include <ext/pb_ds/assoc_container.hpp>
//#include <ext/pb_ds/tree_policy.hpp>

//using namespace __gnu_pbds;
using namespace std;

//template<typename T>
//using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;

typedef vector<int> vi;
typedef long long ll;

#define pb push_back
#define inf 0x3f3f3f3f
#define all(v) (v).begin() , (v).end()
#define ones(n) __builtin_popcount(n)
#define ONES(n) __builtin_popcountll(n)

int di[] = {0, 0, 1, -1, 1, 1, -1, -1};
int dj[] = {1, -1, 0, 0, -1, 1, 1, -1};

struct node {
    int prior , cnt , val;
    int lazy;
    node * left , *right;
    node (int _val) : val(_val) , prior(rand()) , cnt(1) , left(0) , right(0) , lazy(0) {}
    ~node() { delete left , delete right;}
};

using nodePtr = node*;

class Treap {
    nodePtr root;

    int cnt(nodePtr a) {
        return a ? a->cnt : 0;
    }

    void update(nodePtr a) {
        if (a) a->cnt = 1 + cnt(a->left) + cnt(a->right);
    }

    void pushDown(nodePtr &a) {
        if (a && a->lazy) {
            swap(a->left , a->right);
            if (a->left) a->left->lazy ^= 1;
            if (a->right) a->right->lazy ^= 1;
            a->lazy = 0;
        }
    }


    void split (nodePtr cur , nodePtr &l , nodePtr &r , int key , int curKey = 0) {
        pushDown(cur);
        if (!cur)
            return void(l = r = 0);

        curKey += cnt(cur->left) + 1;
        if (key >= curKey)
            split(cur->right , cur->right , r , key , curKey) , l = cur;
        else
            split(cur->left , l , cur->left , key , curKey - cnt(cur->left) - 1) , r = cur;

        update(cur);
    }

    void merge (nodePtr &cur , nodePtr l , nodePtr r) {
        pushDown(l) , pushDown(r);
        if (!l || !r)
            cur = l ? l : r;
        else if (l->prior > r->prior)
            merge(l->right , l->right , r) , cur = l;
        else
            merge(r->left , l , r->left) , cur = r;
        update(cur);
    }

public:
    Treap() : root(0) {}
    ~Treap() {delete root;}

    void insert (int pos , int v) {
        nodePtr a , b , c = new node(v);
        split(root , a , b , pos - 1);
        merge(a , a , c);
        merge(root , a , b);
    }

    void cyclic_shift(int l , int r) {
        nodePtr a , b , c , d;
        split(root , a , b , r);
        split(a , a , c , r - 1);
        split(a , d , a , l - 1);
        merge(a , c , a);
        merge(a , a , b);
        merge(root , d , a);
    }

    void reverse(int l , int r) {
        nodePtr a , b , c;
        split(root , a , b , r);
        split(a , c , a , l - 1);
        a->lazy ^= 1;
        merge(a , c , a);
        merge(root , a , b);
    }

    int at(int i) {
        nodePtr cur = root;
        int curKey = cnt(cur->left) + 1;
        while (curKey != i) {
            if (i > curKey)
                cur = cur->right;
            else {
                curKey -= cnt(cur->left) + 1;
                cur = cur->left;
            }
            pushDown(cur);
            curKey += cnt(cur->left) + 1;
        }
        return cur->val;
    }

};

int main() {
#ifndef ONLINE_JUDGE
    freopen("input.in", "r", stdin);
#endif
    int n , q , m , x;
    scanf("%d%d%d" , &n , &q , &m);

    Treap t;
    for (int i = 1 ;i <= n ;i++) {
        scanf("%d" , &x);
        t.insert(i , x);
    }

    int type , l , r;
    while (q--) {
        scanf("%d%d%d" , &type , &l , &r);
        if (type == 1)
            t.cyclic_shift(l , r);
        else
            t.reverse(l , r);

    }

    for (int i = 0 ;i < m ;i++) {
        scanf("%d" , &x);
        printf("%d " , t.at(x));
    }
}