#include <bits/stdc++.h>

//#include <ext/pb_ds/assoc_container.hpp>
//#include <ext/pb_ds/tree_policy.hpp>

//using namespace __gnu_pbds;
using namespace std;

//template<typename T>
//using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;

typedef vector<int> vi;
typedef long long ll;

#define pb push_back
#define inf 0x3f3f3f3f
#define all(v) (v).begin() , (v).end()
#define ones(n) __builtin_popcount(n)
#define ONES(n) __builtin_popcountll(n)

int di[] = {0, 0, 1, -1, 1, 1, -1, -1};
int dj[] = {1, -1, 0, 0, -1, 1, 1, -1};




struct node {
    int key , prior , cnt ;
    ll s , v , lazy;
    node * left , *right;
    node (int _key , int _prior = rand()) : v(0) , key(_key) , prior(_prior) , left(0) , right(0) , lazy(0) {}
    ~node() { delete left , delete right;}
};

using nodePtr = node*;

class treap {
    nodePtr root;

    ll sum(nodePtr a) {
        pushDown(a);
        return a ? a->s: 0;
    }

    int cnt(nodePtr a) {
        return a ? a->cnt : 0;
    }

    void update(nodePtr a) {
        if (a) {
            a->s = a->v + sum(a->left) + sum(a->right);
            a->cnt = 1 + cnt(a->left) + cnt(a->right);
        }
    }

    void pushDown(nodePtr &a) {
        if (a) {
            a->s += a->lazy * a->cnt , a->v += a->lazy;
            if (a->left) a->left->lazy += a->lazy;
            if (a->right) a->right->lazy += a->lazy;
            a->lazy = 0;
        }
    }

    void insert(nodePtr &cur , nodePtr nw) {
        pushDown(cur);
        if (!cur)
            cur = nw;
        else if (cur->prior > nw->prior)
            insert(nw->key <= cur->key ? cur->left : cur->right , nw);
        else
            split(cur , nw->left , nw->right , nw->key) , cur = nw;

        update(cur);
    }

    void split (nodePtr cur , nodePtr &l , nodePtr &r , int key) {
        pushDown(cur);
        if (!cur)
            l = r = 0;
        else if (key >= cur->key)
            split(cur->right , cur->right , r , key) , l = cur;
        else
            split(cur->left , l , cur->left , key) , r = cur;

        update(cur);
    }

    void merge (nodePtr &cur , nodePtr l , nodePtr r) {
        pushDown(cur);
        if (!l || !r)
            cur = l ? l : r;
        else if (l->prior > r->prior)
            merge(l->right , l->right , r) , cur = l;
        else
            merge(r->left , l , r->left) , cur = r;
        update(cur);
    }

public:
    treap() : root(0) {}
    ~treap() {delete root;}

    ll query(int l , int r) {
        nodePtr a , b , c , d;
        split(root , a , b , l - 1);
        split(b , c , d , r);
        ll ans = sum(c);
        merge(b , c , d);
        merge(root , a , b);
        return ans;
    }

    void update(int l , int r , int val) {
        nodePtr a , b , c , d;
        split(root , a , b , l - 1);
        split(b , c , d , r);
        c->lazy += val;
        pushDown(c);
        merge(b , c , d);
        merge(root , a , b);
    }

    void insert(int key) {
        insert(root , new node(key));
    }

};

int main() {
#ifndef ONLINE_JUDGE
    freopen("input.in", "r", stdin);
#endif
    int T , n , q;
    scanf("%d" , &T);
    while (T--) {
        scanf("%d%d" , &n , &q);

        treap t;
        for (int i = 1 ;i <= n ;i++)
            t.insert(i);

        int type , l , r , val;
        while (q--) {
            scanf("%d%d%d" , &type , &l , &r);
            if (!type) {
                scanf("%d" , &val);
                t.update(l , r , val);
            } else {
                printf("%lld\n" , t.query(l , r));
            }
        }
    }
}