#include <bits/stdc++.h>

using namespace std;

const int N = 1e5 + 5;
int n;
int arr[N] , lazy[4 * N] , segTree[4 * N];

void build(int l = 0, int r = n - 1, int pos = 1) {
    lazy[pos] = 0;
    if (l == r) {
        segTree[pos] = arr[l];
        return;
    }
    int mid = (l + r) / 2;
    build(l, mid, pos * 2);
    build(mid + 1, r, pos * 2 + 1);
    segTree[pos] = segTree[pos * 2] ^ segTree[pos * 2 + 1];
}

void push_down(int l , int r , int pos) {
    if (lazy[pos]) {
        segTree[pos] = ((r-l+1)&1) ? lazy[pos] : 0;
        if (l != r) lazy[pos * 2] = lazy[pos * 2 + 1] = lazy[pos];
        lazy[pos] = 0;
    }
}

void update(int x, int s, int e, int l = 0, int r = n - 1, int pos = 1) {
    push_down(l, r, pos);
    if (l > e || r < s)
        return;

    if (l >= s && r <= e) {
        segTree[pos] = ((r - l + 1)&1) ? x : 0;
        if (l != r) lazy[pos * 2] = lazy[pos * 2 + 1] = x;
        return;
    }

    int mid = (l + r) / 2;
    update(x, s, e, l, mid, pos * 2);
    update(x, s, e, mid + 1, r, pos * 2 + 1);
    segTree[pos] = segTree[pos * 2] ^ segTree[pos * 2 + 1];
}

int query(int s , int e , int l = 0 , int r = n - 1 , int pos = 1) {
    push_down(l , r , pos);
    if (l > e || r < s) return 0;
    if (l >= s && r <= e)return segTree[pos];
    int mid = (l + r) / 2;
    return query(s , e , l , mid , pos * 2) ^ query(s , e , mid + 1 , r , pos * 2 + 1);
}

int main() {
    int T, q;
    scanf("%d", &T);
    while (T--) {
        scanf("%d%d", &n, &q);
        for (int i = 0; i < n; i++)
            scanf("%d", arr + i);

        build();

        int type, s, e, x;
        while (q--) {
            scanf("%d%d%d", &type, &s, &e);
            if (type == 1) {
                printf("%d\n" , query(s - 1 , e - 1));
            } else {
                scanf("%d", &x);
                update(x , s - 1 , e - 1);
            }
        }
    }
}







