struct block {
    int lazy = 0;
    vector<pair<int , int> > v;

    void update() {
        // update the whole block
    }

    void update(int l , int r) {
        // update a range in the block
    }

    int get() {
        // query about the whole block
    }

    int get(int l , int r) {
        // query about a range in the block
    }
};

struct SqareRootDecompo {
    int n , bsz , bcnt;
    vector<block> blocks;

    SqareRootDecompo(vector<int> &a) {
        n = a.size();
        bsz = sqrt(n) + 1;
        bcnt = (a.size() - 1) / bsz + 1;
        blocks = vector<block>(bcnt);

        for (int i = 0 ;i < n ;i++)
            blocks[i / bsz].v.push_back({a[i] , i});

        for (int i = 0 ;i < bcnt ;i++)
            sort(blocks[i].v.begin() , blocks[i].v.end());
    }

    void update(int l , int r) {
        for (int i = l ;i <= r ;) {
            if (i % bsz == 0 && min(i + bsz - 1 , n - 1) <= r) {
                blocks[i / bsz].update();
                i += bsz;
            } else {
                int bid = i / bsz;
                blocks[bid].update(i , min(r , (bid + 1) * bsz - 1));
                i = (bid + 1) * bsz;
            }
        }
    }

    int query(int l , int r) {
        int ret = 0;
        for (int i = l ;i <= r ;) {
            if (i % bsz == 0 && min(i + bsz - 1 , n - 1) <= r) {
                ret += blocks[i / bsz].get();
                i += bsz;
            } else {
                int bid = i / bsz;
                ret += blocks[bid].get(i , min(r , (bid + 1) * bsz - 1));
                i = (bid + 1) * bsz;
            }
        }
        return ret;
    }
};