#include <bits/stdc++.h>

//#include <ext/pb_ds/assoc_container.hpp>
//#include <ext/pb_ds/tree_policy.hpp>

//using namespace __gnu_pbds;
using namespace std;

//template<typename T>
//using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;

typedef vector<int> vi;
typedef long long ll;

#define pb push_back
#define inf 0x3f3f3f3f
#define all(v) (v).begin() , (v).end()
#define ones(n) __builtin_popcount(n)

int di[] = {0, 0, 1, -1, 1, 1, -1, -1};
int dj[] = {1, -1, 0, 0, -1, 1, 1, -1};

struct node {
    ll sum , lazy;
    node *left , *right;
    node () : sum(0) , lazy(0) , left(0) , right(0) {};
    ~node() {delete left , delete right;}
};

using nodePtr = node*;

class segTree {
    const int LN = 0 , RN = 1e5 + 5; // can be negative 
    nodePtr root;

    ll getSum(nodePtr &a) {
        return a ? a->sum : 0;
    }

    void addSum(nodePtr &a , ll v) {
        if (!a) a = new node();
        a->sum += v;
    }

    void addLazy(nodePtr &a , ll v) {
        if (!a) a = new node();
        a->lazy += v;
    }

    void pushDown(nodePtr &cur , ll l , ll r) {
        if (cur && cur->lazy) {
            cur->sum += cur->lazy * (r - l + 1);
            addLazy(cur->left , cur->lazy);
            addLazy(cur->right , cur->lazy);
            cur->lazy = 0;
        }
    }

    void in (ll i , ll v , nodePtr &cur , ll l , ll r) {
        if (i > r || i < l)
            return;

        addSum(cur , v);
        if (l == r)
            return;

        ll mid = l + (r - l) / 2;
        in(i , v  , cur->left, l , mid);
        in(i , v  ,cur->right , mid + 1 , r);
    }

    ll query (ll s , ll e , nodePtr &cur , ll l , ll r) {
        pushDown(cur , l , r);
        if (!cur || l > e || r < s)
            return 0;
        if (l >= s && r <= e)
            return cur->sum;
        ll mid = l + (r - l) / 2;
        return query(s , e , cur->left , l , mid) + query(s , e , cur->right , mid + 1 , r);
    }

    void update(ll s , ll e , ll v , nodePtr &cur , ll l , ll r) {
        pushDown(cur , l , r);
        if (l > e || r < s)
            return ;

        addSum(cur , 0); // to handle if cur = null

        if (l >= s && r <= e) {
            cur->sum += v * (r - l + 1);
            addLazy(cur->left , v);
            addLazy(cur->right , v);
            return;
        }

        ll mid = l + (r - l) / 2;
        update(s , e , v , cur->left , l , mid);
        update(s , e , v,  cur->right , mid + 1 , r);
        cur->sum = getSum(cur->left) + getSum(cur->right);
    }
public:
    segTree() : root(0) {}
    ~segTree() {delete root;}
    void in(ll i , ll v) {
        in(i , v , root , LN , RN);
    }

    ll query(ll s , ll e) {
        return query(s , e , root , LN , RN);
    }

    void update(ll s , ll e , ll v) {
        update(s , e , v , root , LN , RN);
    }
};


int main() {
#ifndef ONLINE_JUDGE
    freopen("input.in", "r", stdin);
#endif
    int T , n , q;
    scanf("%d" , &T);

    while (T--) {
        scanf("%d%d" , &n , &q);
        segTree seg;
        int type , l , r , v;
        while (q--) {
            scanf("%d%d%d" , &type , &l , &r);
            if (!type) {
                scanf("%d" , &v);
                seg.update(l , r , v);
            } else {
                printf("%lld\n" , seg.query(l , r));
            }
        }
    }
}